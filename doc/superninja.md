# Superninja

Superninja enables configure-time visibility of build dependencies across multiple projects by leveraging ninja's subninja mechanism.

The core problems:
- Multiple incompatible build languages (cmake, meson, gn, etc.)
- Isolated project builds with no cross-project incremental capabilities
- Forced sequential builds that waste time and prevent parallelization
- CMake cannot "know" about other CMake dependency graphs, except its current one

Why superninja uniquely solves these:
- True cross-project incremental builds with automatic dependency detection
- Optimal parallelization across project boundaries
- Explicit cross-project dependency expression
- Single-command builds across all projects
- Uniform treatment of all projects in the build graph
- Build system agnostic integration with perfect dependency tracking

Why alternatives can't solve this:
- ExternalProject: Build-time execution prevents dependency visibility
- FetchContent: Only source acquisition, no build integration
- Manual scripts: No dependency analysis or incremental build intelligence
- Submodules: Still isolated builds without unified dependency graph

## The Problem

Traditional multi-project development suffers from fundamental limitations that prevent optimal builds and development workflows:

Each project builds in isolation, unaware of dependencies on other projects. When you change a header file in project A, there's no automatic way to rebuild the affected parts of projects B and C. You must manually rebuild each project in sequence, often rebuilding more than necessary.

ExternalProject and similar approaches force sequential project builds: first project A, then project B, then project C. This prevents parallelization across project boundaries and wastes build time even when projects have independent components that could build simultaneously.

Real dependencies between projects can't be expressed properly. Your main project might depend on a specific header generated by a dependency project, but traditional build systems can't represent this relationship, leading to race conditions or forced sequential builds.

When actively developing multiple related projects, you're forced into a cumbersome cycle: modify project A, manually rebuild it, manually rebuild project B, manually rebuild project C. Each step is a separate command with separate dependency tracking.

Your main project becomes dependent on external build system mechanisms (ExternalProject, FetchContent) that don't integrate cleanly with your local build. You lose the ability to treat all projects uniformly.

On top of all that, CMake isn't the only build system out there.  Many real-world projects rely on meson, gn, shinobi, and other build engines, all of which know nothing about one another.

## The Superninja Solution

Superninja solves these problems by creating a **unified build graph** where ninja can see all dependencies across all projects and make optimal build decisions.

When you change a file in any project, ninja automatically identifies and rebuilds only the affected components across all projects. No manual intervention, no unnecessary rebuilds, no missed dependencies.

Ninja can schedule work across all projects simultaneously. Independent components in different projects build in parallel, while maintaining correct dependency ordering where needed. This dramatically reduces total build time.

You can express precise dependencies between projects: "library in project C depends on headers generated by project A." Ninja enforces these relationships correctly without forcing entire projects to build sequentially.

Modify any file in any project and run a single `ninja` command. The build system automatically determines what needs rebuilding across all projects and executes the minimal necessary work.

Your local project is just another participant in the unified build graph. There's no distinction between "local" and "external" projects - all are first-class citizens with proper dependency representation.

Any build system that generates ninja files (CMake, Meson, rg, custom generators) can integrate seamlessly. The dependency tracking remains perfect regardless of the underlying build system, preserving all incremental build capabilities without losing any build system specific optimizations.

## Why This Can't Be Solved Any Other Way

### ExternalProject Limitations
ExternalProject runs at build time, so CMake can't see cross-project dependencies during configuration. This forces sequential builds and prevents expressing fine-grained dependencies between projects.

### FetchContent Limitations
FetchContent only handles source acquisition. It doesn't solve the build integration problem - you still have isolated project builds without cross-project dependency visibility.

### Manual Build Scripts
Scripts can coordinate builds but can't provide the dependency analysis and incremental build capabilities that ninja offers. You lose the intelligence that makes builds fast and reliable.

### Git Submodules with Separate Builds
Even with all sources available, building projects separately means ninja can't see the complete dependency graph. You're back to manual coordination and suboptimal builds.

## Core Principle

All build dependencies must be expressed at configure time, not build time. This ensures reliable, scalable builds with complete dependency visibility and enables ninja's powerful optimization capabilities across project boundaries.

## Directory Selection Strategy

Superninja follows CMake's ExternalProject directory layout conventions to provide familiar, predictable locations for dependency builds.

### Default Directory Layout

**Without SUPERNINJA_BASE specified:**
- Binary directory: `${CMAKE_BINARY_DIR}/<name>-prefix/src/<name>-build/`
- Ninja file: `${CMAKE_BINARY_DIR}/<name>-prefix/src/<name>-build/build.ninja`

Example: llvm-mos builds in `build/llvm-mos-prefix/src/llvm-mos-build/`

**With SUPERNINJA_BASE specified:**
- Binary directory: `${SUPERNINJA_BASE}/Build/<name>/`
- Ninja file: `${SUPERNINJA_BASE}/Build/<name>/build.ninja`

Example: If `SUPERNINJA_BASE=${CMAKE_BINARY_DIR}/deps`, llvm-mos builds in `build/deps/Build/llvm-mos/`

### ExternalProject Compatibility

This approach ensures Superninja dependencies use the same directory patterns as ExternalProject, making it easy to migrate existing projects or use both systems together without conflicts.

## Variable Expansion

CONFIGURE_COMMAND supports variable expansion using `@VAR@` syntax:

- `@SUPERNINJA_SOURCE_DIR@` - Source directory from FetchContent
- `@SUPERNINJA_BINARY_DIR@` - Calculated binary directory  
- `@SUPERNINJA_NINJA_FILE@` - Expected ninja file location
- Standard CMake variables: `@CMAKE_COMMAND@`, `@CMAKE_BINARY_DIR@`, etc.

## Functions

### Superninja_Declare()

Declares a dependency with source location and build configuration.

**Parameters:**
- Standard FetchContent parameters (GIT_REPOSITORY, GIT_TAG, etc.)
- `CONFIGURE_COMMAND` - Command to configure the dependency's build system
- `NINJA_FILE` - Optional override for ninja file location (auto-calculated if not specified)

### Superninja_Populate()

Downloads sources for a declared dependency without configuring.

### Superninja_MakeAvailable()

Downloads sources and configures build systems for dependencies. Only reconfigures if ninja file doesn't exist or SUPERNINJA_FORCE_RECONFIGURE is set.

### Superninja_Finalize()

Generates master ninja file with subninja directives and inter-project dependencies.

**Parameters:**
- `OUTPUT` - Path to master ninja file
- `DEPENDENCIES` - Inter-project dependency specifications

## Configuration Variables

### SUPERNINJA_BASE

Controls the base directory for all dependency builds. If not set, uses ExternalProject's default `<name>-prefix` pattern.

### SUPERNINJA_FORCE_RECONFIGURE

Forces reconfiguration of all dependencies even if ninja files exist. Useful for structural changes or debugging.

## Benefits

- Complete dependency visibility across projects
- Build language independent architecture
- Optimal build scheduling via unified ninja graph
- User controls all configuration commands and tools
- Variable expansion enables unlimited flexibility
- ExternalProject-compatible directory layout
- Automatic directory management with override capability